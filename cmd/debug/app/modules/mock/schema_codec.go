// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package mock

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *UserAccount) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt(1, e.Nonce)
	return writer.Result()
}

func (e *UserAccount) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *UserAccount) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *UserAccount) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *UserAccount) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	return nil
}

func (e *UserAccount) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	return nil
}

func (e *ValidatorKey) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.Address)
	writer.WriteBytes(2, e.GenerationKey)
	writer.WriteBytes(3, e.BLSKey)
	writer.WriteUInt(4, e.BFTWeight)
	return writer.Result()
}

func (e *ValidatorKey) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ValidatorKey) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ValidatorKey) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ValidatorKey) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.GenerationKey = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	{
		val, err := reader.ReadUInt(4, false)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	return nil
}

func (e *ValidatorKey) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.GenerationKey = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	{
		val, err := reader.ReadUInt(4, true)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	return nil
}

func (e *ValidatorsData) Encode() []byte {
	writer := codec.NewWriter()
	{
		for _, val := range e.Keys {
			if val != nil {
				writer.WriteEncodable(1, val)
			}
		}
	}
	return writer.Result()
}

func (e *ValidatorsData) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ValidatorsData) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ValidatorsData) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ValidatorsData) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(ValidatorKey) })
		if err != nil {
			return err
		}
		r := make([]*ValidatorKey, len(vals))
		for i, v := range vals {
			r[i] = v.(*ValidatorKey)
		}
		e.Keys = r
	}
	return nil
}

func (e *ValidatorsData) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(ValidatorKey) })
		if err != nil {
			return err
		}
		r := make([]*ValidatorKey, len(vals))
		for i, v := range vals {
			r[i] = v.(*ValidatorKey)
		}
		e.Keys = r
	}
	return nil
}
