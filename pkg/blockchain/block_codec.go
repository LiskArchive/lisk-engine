// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package blockchain

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *RawBlock) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Header); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(2, e.Transactions); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(3, e.Assets); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *RawBlock) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *RawBlock) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *RawBlock) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *RawBlock) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *RawBlock) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Header = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.Transactions = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.Assets = val
	}
	return nil
}

func (e *RawBlock) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Header = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.Transactions = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.Assets = val
	}
	return nil
}

func (e *Block) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Header != nil {
		if err := writer.WriteEncodable(1, e.Header); err != nil {
			return nil, err
		}
	}
	{
		for _, val := range e.Transactions {
			if val != nil {
				if err := writer.WriteEncodable(2, val); err != nil {
					return nil, err
				}
			}
		}
	}
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(3, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *Block) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *Block) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Block) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Block) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Block) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(BlockHeader) }, false)
		if err != nil {
			return err
		}
		e.Header = val.(*BlockHeader)
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(Transaction) })
		if err != nil {
			return err
		}
		r := make([]*Transaction, len(vals))
		for i, v := range vals {
			r[i] = v.(*Transaction)
		}
		e.Transactions = r
	}
	{
		vals, err := reader.ReadDecodables(3, func() codec.DecodableReader { return new(BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *Block) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(BlockHeader) }, true)
		if err != nil {
			return err
		}
		e.Header = val.(*BlockHeader)
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(Transaction) })
		if err != nil {
			return err
		}
		r := make([]*Transaction, len(vals))
		for i, v := range vals {
			r[i] = v.(*Transaction)
		}
		e.Transactions = r
	}
	{
		vals, err := reader.ReadDecodables(3, func() codec.DecodableReader { return new(BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *BlockHeader) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.Version); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.Timestamp); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(3, e.Height); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(4, e.PreviousBlockID); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(5, e.GeneratorAddress); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(6, e.TransactionRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(7, e.AssetRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(8, e.EventRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(9, e.StateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(10, e.MaxHeightPrevoted); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(11, e.MaxHeightGenerated); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(12, e.ValidatorsHash); err != nil {
		return nil, err
	}
	if e.AggregateCommit != nil {
		if err := writer.WriteEncodable(13, e.AggregateCommit); err != nil {
			return nil, err
		}
	}
	if err := writer.WriteBytes(14, e.Signature); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *BlockHeader) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *BlockHeader) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BlockHeader) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BlockHeader) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BlockHeader) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.PreviousBlockID = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.GeneratorAddress = val
	}
	{
		val, err := reader.ReadBytes(6, false)
		if err != nil {
			return err
		}
		e.TransactionRoot = val
	}
	{
		val, err := reader.ReadBytes(7, false)
		if err != nil {
			return err
		}
		e.AssetRoot = val
	}
	{
		val, err := reader.ReadBytes(8, false)
		if err != nil {
			return err
		}
		e.EventRoot = val
	}
	{
		val, err := reader.ReadBytes(9, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadUInt32(10, false)
		if err != nil {
			return err
		}
		e.MaxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(11, false)
		if err != nil {
			return err
		}
		e.MaxHeightGenerated = val
	}
	{
		val, err := reader.ReadBytes(12, false)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadDecodable(13, func() codec.DecodableReader { return new(AggregateCommit) }, false)
		if err != nil {
			return err
		}
		e.AggregateCommit = val.(*AggregateCommit)
	}
	{
		val, err := reader.ReadBytes(14, false)
		if err != nil {
			return err
		}
		e.Signature = val
	}
	return nil
}

func (e *BlockHeader) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.PreviousBlockID = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.GeneratorAddress = val
	}
	{
		val, err := reader.ReadBytes(6, true)
		if err != nil {
			return err
		}
		e.TransactionRoot = val
	}
	{
		val, err := reader.ReadBytes(7, true)
		if err != nil {
			return err
		}
		e.AssetRoot = val
	}
	{
		val, err := reader.ReadBytes(8, true)
		if err != nil {
			return err
		}
		e.EventRoot = val
	}
	{
		val, err := reader.ReadBytes(9, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadUInt32(10, true)
		if err != nil {
			return err
		}
		e.MaxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(11, true)
		if err != nil {
			return err
		}
		e.MaxHeightGenerated = val
	}
	{
		val, err := reader.ReadBytes(12, true)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadDecodable(13, func() codec.DecodableReader { return new(AggregateCommit) }, true)
		if err != nil {
			return err
		}
		e.AggregateCommit = val.(*AggregateCommit)
	}
	{
		val, err := reader.ReadBytes(14, true)
		if err != nil {
			return err
		}
		e.Signature = val
	}
	return nil
}

func (e *AggregateCommit) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.Height); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.AggregationBits); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.CertificateSignature); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *AggregateCommit) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *AggregateCommit) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *AggregateCommit) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *AggregateCommit) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *AggregateCommit) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.AggregationBits = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.CertificateSignature = val
	}
	return nil
}

func (e *AggregateCommit) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.AggregationBits = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.CertificateSignature = val
	}
	return nil
}

func (e *signingBlockHeader) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.Version); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.Timestamp); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(3, e.Height); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(4, e.PreviousBlockID); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(5, e.GeneratorAddress); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(6, e.TransactionRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(7, e.AssetRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(8, e.EventRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(9, e.StateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(10, e.MaxHeightPrevoted); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(11, e.MaxHeightGenerated); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(12, e.ValidatorsHash); err != nil {
		return nil, err
	}
	if e.AggregateCommit != nil {
		if err := writer.WriteEncodable(13, e.AggregateCommit); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *signingBlockHeader) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *signingBlockHeader) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *signingBlockHeader) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *signingBlockHeader) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *signingBlockHeader) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.PreviousBlockID = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.GeneratorAddress = val
	}
	{
		val, err := reader.ReadBytes(6, false)
		if err != nil {
			return err
		}
		e.TransactionRoot = val
	}
	{
		val, err := reader.ReadBytes(7, false)
		if err != nil {
			return err
		}
		e.AssetRoot = val
	}
	{
		val, err := reader.ReadBytes(8, false)
		if err != nil {
			return err
		}
		e.EventRoot = val
	}
	{
		val, err := reader.ReadBytes(9, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadUInt32(10, false)
		if err != nil {
			return err
		}
		e.MaxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(11, false)
		if err != nil {
			return err
		}
		e.MaxHeightGenerated = val
	}
	{
		val, err := reader.ReadBytes(12, false)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadDecodable(13, func() codec.DecodableReader { return new(AggregateCommit) }, false)
		if err != nil {
			return err
		}
		e.AggregateCommit = val.(*AggregateCommit)
	}
	return nil
}

func (e *signingBlockHeader) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.PreviousBlockID = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.GeneratorAddress = val
	}
	{
		val, err := reader.ReadBytes(6, true)
		if err != nil {
			return err
		}
		e.TransactionRoot = val
	}
	{
		val, err := reader.ReadBytes(7, true)
		if err != nil {
			return err
		}
		e.AssetRoot = val
	}
	{
		val, err := reader.ReadBytes(8, true)
		if err != nil {
			return err
		}
		e.EventRoot = val
	}
	{
		val, err := reader.ReadBytes(9, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadUInt32(10, true)
		if err != nil {
			return err
		}
		e.MaxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(11, true)
		if err != nil {
			return err
		}
		e.MaxHeightGenerated = val
	}
	{
		val, err := reader.ReadBytes(12, true)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadDecodable(13, func() codec.DecodableReader { return new(AggregateCommit) }, true)
		if err != nil {
			return err
		}
		e.AggregateCommit = val.(*AggregateCommit)
	}
	return nil
}

func (e *BlockAsset) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteString(1, e.Module); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.Data); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *BlockAsset) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *BlockAsset) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BlockAsset) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BlockAsset) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BlockAsset) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}

func (e *BlockAsset) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}
