// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package blockchain

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *Transaction) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteString(1, e.Module)
	writer.WriteString(2, e.Command)
	writer.WriteUInt(3, e.Nonce)
	writer.WriteUInt(4, e.Fee)
	writer.WriteBytes(5, e.SenderPublicKey)
	writer.WriteBytes(6, e.Params)
	writer.WriteBytesArray(7, codec.HexArrayToBytesArray(e.Signatures))
	return writer.Result()
}

func (e *Transaction) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Transaction) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Transaction) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Transaction) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadString(2, false)
		if err != nil {
			return err
		}
		e.Command = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt(4, false)
		if err != nil {
			return err
		}
		e.Fee = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.SenderPublicKey = val
	}
	{
		val, err := reader.ReadBytes(6, false)
		if err != nil {
			return err
		}
		e.Params = val
	}
	{
		val, err := reader.ReadBytesArray(7)
		if err != nil {
			return err
		}
		e.Signatures = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *Transaction) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadString(2, true)
		if err != nil {
			return err
		}
		e.Command = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt(4, true)
		if err != nil {
			return err
		}
		e.Fee = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.SenderPublicKey = val
	}
	{
		val, err := reader.ReadBytes(6, true)
		if err != nil {
			return err
		}
		e.Params = val
	}
	{
		val, err := reader.ReadBytesArray(7)
		if err != nil {
			return err
		}
		e.Signatures = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *SigningTransaction) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteString(1, e.Module)
	writer.WriteString(2, e.Command)
	writer.WriteUInt(3, e.Nonce)
	writer.WriteUInt(4, e.Fee)
	writer.WriteBytes(5, e.SenderPublicKey)
	writer.WriteBytes(6, e.Params)
	return writer.Result()
}

func (e *SigningTransaction) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *SigningTransaction) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *SigningTransaction) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *SigningTransaction) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadString(2, false)
		if err != nil {
			return err
		}
		e.Command = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt(4, false)
		if err != nil {
			return err
		}
		e.Fee = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.SenderPublicKey = val
	}
	{
		val, err := reader.ReadBytes(6, false)
		if err != nil {
			return err
		}
		e.Params = val
	}
	return nil
}

func (e *SigningTransaction) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.Module = val
	}
	{
		val, err := reader.ReadString(2, true)
		if err != nil {
			return err
		}
		e.Command = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt(4, true)
		if err != nil {
			return err
		}
		e.Fee = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.SenderPublicKey = val
	}
	{
		val, err := reader.ReadBytes(6, true)
		if err != nil {
			return err
		}
		e.Params = val
	}
	return nil
}
