// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package certificate

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *Certificate) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.BlockID)
	writer.WriteUInt32(2, e.Height)
	writer.WriteUInt32(3, e.Timestamp)
	writer.WriteBytes(4, e.StateRoot)
	writer.WriteBytes(5, e.ValidatorsHash)
	writer.WriteBytes(6, e.AggregationBits)
	writer.WriteBytes(7, e.Signature)
	return writer.Result()
}

func (e *Certificate) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Certificate) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Certificate) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Certificate) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.BlockID = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadBytes(6, false)
		if err != nil {
			return err
		}
		e.AggregationBits = val
	}
	{
		val, err := reader.ReadBytes(7, false)
		if err != nil {
			return err
		}
		e.Signature = val
	}
	return nil
}

func (e *Certificate) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.BlockID = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	{
		val, err := reader.ReadBytes(6, true)
		if err != nil {
			return err
		}
		e.AggregationBits = val
	}
	{
		val, err := reader.ReadBytes(7, true)
		if err != nil {
			return err
		}
		e.Signature = val
	}
	return nil
}

func (e *SigningCertificate) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.BlockID)
	writer.WriteUInt32(2, e.Height)
	writer.WriteUInt32(3, e.Timestamp)
	writer.WriteBytes(4, e.StateRoot)
	writer.WriteBytes(5, e.ValidatorsHash)
	return writer.Result()
}

func (e *SigningCertificate) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *SigningCertificate) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *SigningCertificate) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *SigningCertificate) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.BlockID = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	return nil
}

func (e *SigningCertificate) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.BlockID = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Height = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.Timestamp = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.ValidatorsHash = val
	}
	return nil
}

func (e *SingleCommit) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.blockID)
	writer.WriteUInt32(2, e.height)
	writer.WriteBytes(3, e.validatorAddress)
	writer.WriteBytes(4, e.certificateSignature)
	return writer.Result()
}

func (e *SingleCommit) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *SingleCommit) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *SingleCommit) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *SingleCommit) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.blockID = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.height = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.validatorAddress = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.certificateSignature = val
	}
	return nil
}

func (e *SingleCommit) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.blockID = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.height = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.validatorAddress = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.certificateSignature = val
	}
	return nil
}
