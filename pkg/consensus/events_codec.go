// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package consensus

import (
	"github.com/LiskHQ/lisk-engine/pkg/blockchain"
	"github.com/LiskHQ/lisk-engine/pkg/codec"
	"github.com/LiskHQ/lisk-engine/pkg/labi"
)

func (e *EventNetworkBlockNewMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Block != nil {
		if err := writer.WriteEncodable(1, e.Block); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *EventNetworkBlockNewMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventNetworkBlockNewMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventNetworkBlockNewMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventNetworkBlockNewMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventNetworkBlockNewMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, false)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventNetworkBlockNewMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, true)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventBlockNewMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Block != nil {
		if err := writer.WriteEncodable(1, e.Block); err != nil {
			return nil, err
		}
	}
	{
		for _, val := range e.Events {
			if val != nil {
				if err := writer.WriteEncodable(2, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *EventBlockNewMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventBlockNewMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventBlockNewMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventBlockNewMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventBlockNewMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, false)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	return nil
}

func (e *EventBlockNewMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, true)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	return nil
}

func (e *EventBlockDeleteMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Block != nil {
		if err := writer.WriteEncodable(1, e.Block); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *EventBlockDeleteMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventBlockDeleteMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventBlockDeleteMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventBlockDeleteMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventBlockDeleteMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, false)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventBlockDeleteMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, true)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventChainForkMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Block != nil {
		if err := writer.WriteEncodable(1, e.Block); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *EventChainForkMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventChainForkMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventChainForkMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventChainForkMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventChainForkMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, false)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventChainForkMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.Block) }, true)
		if err != nil {
			return err
		}
		e.Block = val.(*blockchain.Block)
	}
	return nil
}

func (e *EventChangeValidator) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.NextValidators {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteUInt(2, e.PrecommitThreshold); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt(3, e.CertificateThreshold); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *EventChangeValidator) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventChangeValidator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventChangeValidator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventChangeValidator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventChangeValidator) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(labi.Validator) })
		if err != nil {
			return err
		}
		r := make([]*labi.Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*labi.Validator)
		}
		e.NextValidators = r
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.PrecommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *EventChangeValidator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(labi.Validator) })
		if err != nil {
			return err
		}
		r := make([]*labi.Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*labi.Validator)
		}
		e.NextValidators = r
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.PrecommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *EventBlockFinalizeMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.Original); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.Next); err != nil {
		return nil, err
	}
	if e.Trigger != nil {
		if err := writer.WriteEncodable(3, e.Trigger); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *EventBlockFinalizeMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EventBlockFinalizeMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EventBlockFinalizeMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EventBlockFinalizeMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EventBlockFinalizeMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.Original = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Next = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, false)
		if err != nil {
			return err
		}
		e.Trigger = val.(*blockchain.BlockHeader)
	}
	return nil
}

func (e *EventBlockFinalizeMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.Original = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Next = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, true)
		if err != nil {
			return err
		}
		e.Trigger = val.(*blockchain.BlockHeader)
	}
	return nil
}
