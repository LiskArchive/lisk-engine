// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package liskbft

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *ActiveValidator) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.address)
	writer.WriteUInt32(2, e.minActiveHeight)
	writer.WriteUInt32(3, e.largestHeightPrecommit)
	return writer.Result()
}

func (e *ActiveValidator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ActiveValidator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ActiveValidator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ActiveValidator) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.minActiveHeight = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.largestHeightPrecommit = val
	}
	return nil
}

func (e *ActiveValidator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.minActiveHeight = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.largestHeightPrecommit = val
	}
	return nil
}

func (e *BFTValidator) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.address)
	writer.WriteUInt(2, e.bftWeight)
	writer.WriteBytes(3, e.blsKey)
	return writer.Result()
}

func (e *BFTValidator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BFTValidator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BFTValidator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BFTValidator) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.bftWeight = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.blsKey = val
	}
	return nil
}

func (e *BFTValidator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.bftWeight = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.blsKey = val
	}
	return nil
}

func (e *BFTParams) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt(1, e.prevoteThreshold)
	writer.WriteUInt(2, e.precommitThreshold)
	writer.WriteUInt(3, e.certificateThreshold)
	{
		for _, val := range e.validators {
			if val != nil {
				writer.WriteEncodable(4, val)
			}
		}
	}
	writer.WriteBytes(5, e.validatorsHash)
	return writer.Result()
}

func (e *BFTParams) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BFTParams) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BFTParams) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BFTParams) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.prevoteThreshold = val
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.precommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.certificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(BFTValidator) })
		if err != nil {
			return err
		}
		r := make([]*BFTValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*BFTValidator)
		}
		e.validators = r
	}
	{
		val, err := reader.ReadBytes(5, false)
		if err != nil {
			return err
		}
		e.validatorsHash = val
	}
	return nil
}

func (e *BFTParams) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.prevoteThreshold = val
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.precommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.certificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(BFTValidator) })
		if err != nil {
			return err
		}
		r := make([]*BFTValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*BFTValidator)
		}
		e.validators = r
	}
	{
		val, err := reader.ReadBytes(5, true)
		if err != nil {
			return err
		}
		e.validatorsHash = val
	}
	return nil
}

func (e *BFTBlockHeader) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt32(1, e.height)
	writer.WriteBytes(2, e.generatorAddress)
	writer.WriteUInt32(3, e.maxHeightGenerated)
	writer.WriteUInt32(4, e.maxHeightPrevoted)
	writer.WriteUInt(5, e.prevoteWeight)
	writer.WriteUInt(6, e.precommitWeight)
	return writer.Result()
}

func (e *BFTBlockHeader) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BFTBlockHeader) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BFTBlockHeader) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BFTBlockHeader) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.height = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.generatorAddress = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.maxHeightGenerated = val
	}
	{
		val, err := reader.ReadUInt32(4, false)
		if err != nil {
			return err
		}
		e.maxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt(5, false)
		if err != nil {
			return err
		}
		e.prevoteWeight = val
	}
	{
		val, err := reader.ReadUInt(6, false)
		if err != nil {
			return err
		}
		e.precommitWeight = val
	}
	return nil
}

func (e *BFTBlockHeader) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.height = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.generatorAddress = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.maxHeightGenerated = val
	}
	{
		val, err := reader.ReadUInt32(4, true)
		if err != nil {
			return err
		}
		e.maxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt(5, true)
		if err != nil {
			return err
		}
		e.prevoteWeight = val
	}
	{
		val, err := reader.ReadUInt(6, true)
		if err != nil {
			return err
		}
		e.precommitWeight = val
	}
	return nil
}

func (e *BFTVotes) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt32(1, e.maxHeightPrevoted)
	writer.WriteUInt32(2, e.maxHeightPrecommited)
	writer.WriteUInt32(3, e.maxHeightCertified)
	{
		for _, val := range e.blockBFTInfos {
			if val != nil {
				writer.WriteEncodable(5, val)
			}
		}
	}
	{
		for _, val := range e.activeValidatorsVoteInfo {
			if val != nil {
				writer.WriteEncodable(6, val)
			}
		}
	}
	return writer.Result()
}

func (e *BFTVotes) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BFTVotes) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BFTVotes) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BFTVotes) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.maxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.maxHeightPrecommited = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.maxHeightCertified = val
	}
	{
		vals, err := reader.ReadDecodables(5, func() codec.DecodableReader { return new(BFTBlockHeader) })
		if err != nil {
			return err
		}
		r := make([]*BFTBlockHeader, len(vals))
		for i, v := range vals {
			r[i] = v.(*BFTBlockHeader)
		}
		e.blockBFTInfos = r
	}
	{
		vals, err := reader.ReadDecodables(6, func() codec.DecodableReader { return new(ActiveValidator) })
		if err != nil {
			return err
		}
		r := make([]*ActiveValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*ActiveValidator)
		}
		e.activeValidatorsVoteInfo = r
	}
	return nil
}

func (e *BFTVotes) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.maxHeightPrevoted = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.maxHeightPrecommited = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.maxHeightCertified = val
	}
	{
		vals, err := reader.ReadDecodables(5, func() codec.DecodableReader { return new(BFTBlockHeader) })
		if err != nil {
			return err
		}
		r := make([]*BFTBlockHeader, len(vals))
		for i, v := range vals {
			r[i] = v.(*BFTBlockHeader)
		}
		e.blockBFTInfos = r
	}
	{
		vals, err := reader.ReadDecodables(6, func() codec.DecodableReader { return new(ActiveValidator) })
		if err != nil {
			return err
		}
		r := make([]*ActiveValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*ActiveValidator)
		}
		e.activeValidatorsVoteInfo = r
	}
	return nil
}

func (e *HashValidator) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.BLSKey)
	writer.WriteUInt(2, e.BFTWeight)
	return writer.Result()
}

func (e *HashValidator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *HashValidator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *HashValidator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *HashValidator) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	return nil
}

func (e *HashValidator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	return nil
}

func (e *HashingValidators) Encode() []byte {
	writer := codec.NewWriter()
	{
		for _, val := range e.ActiveValidators {
			if val != nil {
				writer.WriteEncodable(1, val)
			}
		}
	}
	writer.WriteUInt(2, e.CertificateThreshold)
	return writer.Result()
}

func (e *HashingValidators) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *HashingValidators) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *HashingValidators) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *HashingValidators) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(HashValidator) })
		if err != nil {
			return err
		}
		r := make([]*HashValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*HashValidator)
		}
		e.ActiveValidators = r
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *HashingValidators) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(HashValidator) })
		if err != nil {
			return err
		}
		r := make([]*HashValidator, len(vals))
		for i, v := range vals {
			r[i] = v.(*HashValidator)
		}
		e.ActiveValidators = r
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *Generator) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteBytes(1, e.address)
	writer.WriteBytes(2, e.generatorKey)
	return writer.Result()
}

func (e *Generator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Generator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Generator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Generator) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.generatorKey = val
	}
	return nil
}

func (e *Generator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.address = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.generatorKey = val
	}
	return nil
}

func (e *GeneratorKeys) Encode() []byte {
	writer := codec.NewWriter()
	{
		for _, val := range e.Generators {
			if val != nil {
				writer.WriteEncodable(1, val)
			}
		}
	}
	return writer.Result()
}

func (e *GeneratorKeys) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *GeneratorKeys) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *GeneratorKeys) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *GeneratorKeys) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(Generator) })
		if err != nil {
			return err
		}
		r := make([]*Generator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Generator)
		}
		e.Generators = r
	}
	return nil
}

func (e *GeneratorKeys) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(Generator) })
		if err != nil {
			return err
		}
		r := make([]*Generator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Generator)
		}
		e.Generators = r
	}
	return nil
}
