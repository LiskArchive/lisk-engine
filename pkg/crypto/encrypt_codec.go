// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package crypto

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *KDFParams) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.Parallelism); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.Iterations); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(4, e.Salt); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *KDFParams) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *KDFParams) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *KDFParams) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *KDFParams) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *KDFParams) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.Parallelism = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.Iterations = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.Salt = val
	}
	return nil
}

func (e *KDFParams) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.Parallelism = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.Iterations = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.Salt = val
	}
	return nil
}

func (e *CipherParams) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.IV); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.Tag); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *CipherParams) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *CipherParams) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *CipherParams) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *CipherParams) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *CipherParams) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.IV = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.Tag = val
	}
	return nil
}

func (e *CipherParams) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.IV = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.Tag = val
	}
	return nil
}

func (e *EncryptedMessage) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteString(1, e.Version); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.CipherText); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.Mac); err != nil {
		return nil, err
	}
	if err := writer.WriteString(4, e.KDF); err != nil {
		return nil, err
	}
	if e.KDFParams != nil {
		if err := writer.WriteEncodable(5, e.KDFParams); err != nil {
			return nil, err
		}
	}
	if err := writer.WriteString(6, e.Cipher); err != nil {
		return nil, err
	}
	if e.CipherParams != nil {
		if err := writer.WriteEncodable(7, e.CipherParams); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *EncryptedMessage) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *EncryptedMessage) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *EncryptedMessage) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *EncryptedMessage) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *EncryptedMessage) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.CipherText = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.Mac = val
	}
	{
		val, err := reader.ReadString(4, false)
		if err != nil {
			return err
		}
		e.KDF = val
	}
	{
		val, err := reader.ReadDecodable(5, func() codec.DecodableReader { return new(KDFParams) }, false)
		if err != nil {
			return err
		}
		e.KDFParams = val.(*KDFParams)
	}
	{
		val, err := reader.ReadString(6, false)
		if err != nil {
			return err
		}
		e.Cipher = val
	}
	{
		val, err := reader.ReadDecodable(7, func() codec.DecodableReader { return new(CipherParams) }, false)
		if err != nil {
			return err
		}
		e.CipherParams = val.(*CipherParams)
	}
	return nil
}

func (e *EncryptedMessage) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.Version = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.CipherText = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.Mac = val
	}
	{
		val, err := reader.ReadString(4, true)
		if err != nil {
			return err
		}
		e.KDF = val
	}
	{
		val, err := reader.ReadDecodable(5, func() codec.DecodableReader { return new(KDFParams) }, true)
		if err != nil {
			return err
		}
		e.KDFParams = val.(*KDFParams)
	}
	{
		val, err := reader.ReadString(6, true)
		if err != nil {
			return err
		}
		e.Cipher = val
	}
	{
		val, err := reader.ReadDecodable(7, func() codec.DecodableReader { return new(CipherParams) }, true)
		if err != nil {
			return err
		}
		e.CipherParams = val.(*CipherParams)
	}
	return nil
}
