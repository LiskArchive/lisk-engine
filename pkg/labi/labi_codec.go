// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package labi

import (
	"github.com/LiskHQ/lisk-engine/pkg/blockchain"
	"github.com/LiskHQ/lisk-engine/pkg/codec"
	"github.com/LiskHQ/lisk-engine/pkg/trie/smt"
)

func (e *InitRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ChainID); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.LastBlockHeight); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.LastStateRoot); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *InitRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InitRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InitRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InitRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InitRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ChainID = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.LastBlockHeight = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.LastStateRoot = val
	}
	return nil
}

func (e *InitRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ChainID = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.LastBlockHeight = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.LastStateRoot = val
	}
	return nil
}

func (e *InitStateMachineRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Header != nil {
		if err := writer.WriteEncodable(1, e.Header); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *InitStateMachineRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InitStateMachineRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InitStateMachineRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InitStateMachineRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InitStateMachineRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, false)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	return nil
}

func (e *InitStateMachineRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, true)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	return nil
}

func (e *InitStateMachineResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *InitStateMachineResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InitStateMachineResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InitStateMachineResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InitStateMachineResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InitStateMachineResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	return nil
}

func (e *InitStateMachineResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	return nil
}

func (e *InitGenesisStateRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *InitGenesisStateRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InitGenesisStateRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InitGenesisStateRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InitGenesisStateRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InitGenesisStateRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	return nil
}

func (e *InitGenesisStateRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	return nil
}

func (e *InitGenesisStateResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.Events {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteUInt(2, e.PreCommitThreshold); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt(3, e.CertificateThreshold); err != nil {
		return nil, err
	}
	{
		for _, val := range e.NextValidators {
			if val != nil {
				if err := writer.WriteEncodable(4, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *InitGenesisStateResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InitGenesisStateResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InitGenesisStateResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InitGenesisStateResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InitGenesisStateResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.PreCommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.NextValidators = r
	}
	return nil
}

func (e *InitGenesisStateResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.PreCommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.NextValidators = r
	}
	return nil
}

func (e *InsertAssetsRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.FinalizedHeight); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *InsertAssetsRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InsertAssetsRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InsertAssetsRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InsertAssetsRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InsertAssetsRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.FinalizedHeight = val
	}
	return nil
}

func (e *InsertAssetsRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.FinalizedHeight = val
	}
	return nil
}

func (e *InsertAssetsResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *InsertAssetsResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *InsertAssetsResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *InsertAssetsResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *InsertAssetsResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *InsertAssetsResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *InsertAssetsResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *VerifyAssetsRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(2, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *VerifyAssetsRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *VerifyAssetsRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *VerifyAssetsRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *VerifyAssetsRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *VerifyAssetsRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *VerifyAssetsRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	return nil
}

func (e *Validator) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Address); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt(2, e.BFTWeight); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.GeneratorKey); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(4, e.BLSKey); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *Validator) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *Validator) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Validator) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Validator) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Validator) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.GeneratorKey = val
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	return nil
}

func (e *Validator) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.BFTWeight = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.GeneratorKey = val
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.BLSKey = val
	}
	return nil
}

func (e *Consensus) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.CurrentValidators {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteBool(2, e.ImplyMaxPrevote); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(3, e.MaxHeightCertified); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt(4, e.CertificateThreshold); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *Consensus) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *Consensus) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *Consensus) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *Consensus) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *Consensus) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.CurrentValidators = r
	}
	{
		val, err := reader.ReadBool(2, false)
		if err != nil {
			return err
		}
		e.ImplyMaxPrevote = val
	}
	{
		val, err := reader.ReadUInt32(3, false)
		if err != nil {
			return err
		}
		e.MaxHeightCertified = val
	}
	{
		val, err := reader.ReadUInt(4, false)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *Consensus) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.CurrentValidators = r
	}
	{
		val, err := reader.ReadBool(2, true)
		if err != nil {
			return err
		}
		e.ImplyMaxPrevote = val
	}
	{
		val, err := reader.ReadUInt32(3, true)
		if err != nil {
			return err
		}
		e.MaxHeightCertified = val
	}
	{
		val, err := reader.ReadUInt(4, true)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	return nil
}

func (e *BeforeTransactionsExecuteRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(2, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if e.Consensus != nil {
		if err := writer.WriteEncodable(3, e.Consensus); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *BeforeTransactionsExecuteRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *BeforeTransactionsExecuteRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BeforeTransactionsExecuteRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BeforeTransactionsExecuteRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BeforeTransactionsExecuteRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(Consensus) }, false)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	return nil
}

func (e *BeforeTransactionsExecuteRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(Consensus) }, true)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	return nil
}

func (e *BeforeTransactionsExecuteResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.Events {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *BeforeTransactionsExecuteResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *BeforeTransactionsExecuteResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *BeforeTransactionsExecuteResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *BeforeTransactionsExecuteResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *BeforeTransactionsExecuteResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	return nil
}

func (e *BeforeTransactionsExecuteResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	return nil
}

func (e *AfterTransactionsExecuteRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(2, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if e.Consensus != nil {
		if err := writer.WriteEncodable(3, e.Consensus); err != nil {
			return nil, err
		}
	}
	{
		for _, val := range e.Transactions {
			if val != nil {
				if err := writer.WriteEncodable(4, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *AfterTransactionsExecuteRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *AfterTransactionsExecuteRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *AfterTransactionsExecuteRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *AfterTransactionsExecuteRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *AfterTransactionsExecuteRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(Consensus) }, false)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(blockchain.Transaction) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Transaction, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Transaction)
		}
		e.Transactions = r
	}
	return nil
}

func (e *AfterTransactionsExecuteRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		vals, err := reader.ReadDecodables(2, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(Consensus) }, true)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(blockchain.Transaction) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Transaction, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Transaction)
		}
		e.Transactions = r
	}
	return nil
}

func (e *AfterTransactionsExecuteResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.Events {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteUInt(2, e.PreCommitThreshold); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt(3, e.CertificateThreshold); err != nil {
		return nil, err
	}
	{
		for _, val := range e.NextValidators {
			if val != nil {
				if err := writer.WriteEncodable(4, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *AfterTransactionsExecuteResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *AfterTransactionsExecuteResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *AfterTransactionsExecuteResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *AfterTransactionsExecuteResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *AfterTransactionsExecuteResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadUInt(2, false)
		if err != nil {
			return err
		}
		e.PreCommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, false)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.NextValidators = r
	}
	return nil
}

func (e *AfterTransactionsExecuteResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadUInt(2, true)
		if err != nil {
			return err
		}
		e.PreCommitThreshold = val
	}
	{
		val, err := reader.ReadUInt(3, true)
		if err != nil {
			return err
		}
		e.CertificateThreshold = val
	}
	{
		vals, err := reader.ReadDecodables(4, func() codec.DecodableReader { return new(Validator) })
		if err != nil {
			return err
		}
		r := make([]*Validator, len(vals))
		for i, v := range vals {
			r[i] = v.(*Validator)
		}
		e.NextValidators = r
	}
	return nil
}

func (e *VerifyTransactionRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	if e.Transaction != nil {
		if err := writer.WriteEncodable(2, e.Transaction); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *VerifyTransactionRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *VerifyTransactionRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *VerifyTransactionRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *VerifyTransactionRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *VerifyTransactionRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(blockchain.Transaction) }, false)
		if err != nil {
			return err
		}
		e.Transaction = val.(*blockchain.Transaction)
	}
	return nil
}

func (e *VerifyTransactionRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(blockchain.Transaction) }, true)
		if err != nil {
			return err
		}
		e.Transaction = val.(*blockchain.Transaction)
	}
	return nil
}

func (e *VerifyTransactionResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteInt32(1, e.Result); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *VerifyTransactionResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *VerifyTransactionResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *VerifyTransactionResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *VerifyTransactionResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *VerifyTransactionResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadInt32(1, false)
		if err != nil {
			return err
		}
		e.Result = val
	}
	return nil
}

func (e *VerifyTransactionResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadInt32(1, true)
		if err != nil {
			return err
		}
		e.Result = val
	}
	return nil
}

func (e *ExecuteTransactionRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	if e.Transaction != nil {
		if err := writer.WriteEncodable(2, e.Transaction); err != nil {
			return nil, err
		}
	}
	{
		for _, val := range e.Assets {
			if val != nil {
				if err := writer.WriteEncodable(3, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteBool(4, e.DryRun); err != nil {
		return nil, err
	}
	if e.Header != nil {
		if err := writer.WriteEncodable(5, e.Header); err != nil {
			return nil, err
		}
	}
	if e.Consensus != nil {
		if err := writer.WriteEncodable(6, e.Consensus); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *ExecuteTransactionRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *ExecuteTransactionRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ExecuteTransactionRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ExecuteTransactionRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ExecuteTransactionRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(blockchain.Transaction) }, false)
		if err != nil {
			return err
		}
		e.Transaction = val.(*blockchain.Transaction)
	}
	{
		vals, err := reader.ReadDecodables(3, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadBool(4, false)
		if err != nil {
			return err
		}
		e.DryRun = val
	}
	{
		val, err := reader.ReadDecodable(5, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, false)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	{
		val, err := reader.ReadDecodable(6, func() codec.DecodableReader { return new(Consensus) }, false)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	return nil
}

func (e *ExecuteTransactionRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(blockchain.Transaction) }, true)
		if err != nil {
			return err
		}
		e.Transaction = val.(*blockchain.Transaction)
	}
	{
		vals, err := reader.ReadDecodables(3, func() codec.DecodableReader { return new(blockchain.BlockAsset) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.BlockAsset, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.BlockAsset)
		}
		e.Assets = r
	}
	{
		val, err := reader.ReadBool(4, true)
		if err != nil {
			return err
		}
		e.DryRun = val
	}
	{
		val, err := reader.ReadDecodable(5, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, true)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	{
		val, err := reader.ReadDecodable(6, func() codec.DecodableReader { return new(Consensus) }, true)
		if err != nil {
			return err
		}
		e.Consensus = val.(*Consensus)
	}
	return nil
}

func (e *ExecuteTransactionResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.Events {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	if err := writer.WriteInt32(2, e.Result); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *ExecuteTransactionResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *ExecuteTransactionResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ExecuteTransactionResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ExecuteTransactionResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ExecuteTransactionResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadInt32(2, false)
		if err != nil {
			return err
		}
		e.Result = val
	}
	return nil
}

func (e *ExecuteTransactionResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(blockchain.Event) })
		if err != nil {
			return err
		}
		r := make([]*blockchain.Event, len(vals))
		for i, v := range vals {
			r[i] = v.(*blockchain.Event)
		}
		e.Events = r
	}
	{
		val, err := reader.ReadInt32(2, true)
		if err != nil {
			return err
		}
		e.Result = val
	}
	return nil
}

func (e *CommitRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.StateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.ExpectedStateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBool(4, e.DryRun); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *CommitRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *CommitRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *CommitRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *CommitRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *CommitRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.ExpectedStateRoot = val
	}
	{
		val, err := reader.ReadBool(4, false)
		if err != nil {
			return err
		}
		e.DryRun = val
	}
	return nil
}

func (e *CommitRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.ExpectedStateRoot = val
	}
	{
		val, err := reader.ReadBool(4, true)
		if err != nil {
			return err
		}
		e.DryRun = val
	}
	return nil
}

func (e *CommitResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.StateRoot); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *CommitResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *CommitResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *CommitResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *CommitResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *CommitResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	return nil
}

func (e *CommitResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	return nil
}

func (e *RevertRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.ContextID); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.StateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(3, e.ExpectedStateRoot); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *RevertRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *RevertRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *RevertRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *RevertRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *RevertRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.ExpectedStateRoot = val
	}
	return nil
}

func (e *RevertRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.ContextID = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.ExpectedStateRoot = val
	}
	return nil
}

func (e *RevertResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.StateRoot); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *RevertResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *RevertResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *RevertResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *RevertResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *RevertResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	return nil
}

func (e *RevertResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	return nil
}

func (e *FinalizeRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.FinalizedHeight); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *FinalizeRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *FinalizeRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *FinalizeRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *FinalizeRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *FinalizeRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.FinalizedHeight = val
	}
	return nil
}

func (e *FinalizeRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.FinalizedHeight = val
	}
	return nil
}

func (e *MetadataResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Data); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *MetadataResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *MetadataResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *MetadataResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *MetadataResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *MetadataResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}

func (e *MetadataResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}

func (e *QueryRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteString(1, e.Method); err != nil {
		return nil, err
	}
	if err := writer.WriteBytes(2, e.Params); err != nil {
		return nil, err
	}
	if e.Header != nil {
		if err := writer.WriteEncodable(3, e.Header); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *QueryRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *QueryRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *QueryRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *QueryRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *QueryRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.Method = val
	}
	{
		val, err := reader.ReadBytes(2, false)
		if err != nil {
			return err
		}
		e.Params = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, false)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	return nil
}

func (e *QueryRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.Method = val
	}
	{
		val, err := reader.ReadBytes(2, true)
		if err != nil {
			return err
		}
		e.Params = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(blockchain.BlockHeader) }, true)
		if err != nil {
			return err
		}
		e.Header = val.(*blockchain.BlockHeader)
	}
	return nil
}

func (e *QueryResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Data); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *QueryResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *QueryResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *QueryResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *QueryResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *QueryResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}

func (e *QueryResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Data = val
	}
	return nil
}

func (e *ProveRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.StateRoot); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(2, codec.HexArrayToBytesArray(e.Keys)); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *ProveRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *ProveRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ProveRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ProveRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ProveRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.Keys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *ProveRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.StateRoot = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.Keys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *ProveResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if e.Result != nil {
		if err := writer.WriteEncodable(1, e.Result); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *ProveResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *ProveResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ProveResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ProveResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ProveResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(smt.Proof) }, false)
		if err != nil {
			return err
		}
		e.Result = val.(*smt.Proof)
	}
	return nil
}

func (e *ProveResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadDecodable(1, func() codec.DecodableReader { return new(smt.Proof) }, true)
		if err != nil {
			return err
		}
		e.Result = val.(*smt.Proof)
	}
	return nil
}
