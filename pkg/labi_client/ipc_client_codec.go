// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package labi_client

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *ipcRequest) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt(1, e.id)
	writer.WriteString(2, e.method)
	writer.WriteBytes(3, e.params)
	return writer.Result()
}

func (e *ipcRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ipcRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ipcRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ipcRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.id = val
	}
	{
		val, err := reader.ReadString(2, false)
		if err != nil {
			return err
		}
		e.method = val
	}
	{
		val, err := reader.ReadBytes(3, false)
		if err != nil {
			return err
		}
		e.params = val
	}
	return nil
}

func (e *ipcRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.id = val
	}
	{
		val, err := reader.ReadString(2, true)
		if err != nil {
			return err
		}
		e.method = val
	}
	{
		val, err := reader.ReadBytes(3, true)
		if err != nil {
			return err
		}
		e.params = val
	}
	return nil
}

func (e *errObj) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteString(1, e.message)
	return writer.Result()
}

func (e *errObj) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *errObj) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *errObj) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *errObj) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, false)
		if err != nil {
			return err
		}
		e.message = val
	}
	return nil
}

func (e *errObj) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadString(1, true)
		if err != nil {
			return err
		}
		e.message = val
	}
	return nil
}

func (e *ipcResponse) Encode() []byte {
	writer := codec.NewWriter()
	writer.WriteUInt(1, e.id)
	writer.WriteBool(2, e.success)
	if e.err != nil {
		writer.WriteEncodable(3, e.err)
	}
	writer.WriteBytes(4, e.result)
	return writer.Result()
}

func (e *ipcResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *ipcResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *ipcResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *ipcResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.id = val
	}
	{
		val, err := reader.ReadBool(2, false)
		if err != nil {
			return err
		}
		e.success = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(errObj) }, false)
		if err != nil {
			return err
		}
		e.err = val.(*errObj)
	}
	{
		val, err := reader.ReadBytes(4, false)
		if err != nil {
			return err
		}
		e.result = val
	}
	return nil
}

func (e *ipcResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.id = val
	}
	{
		val, err := reader.ReadBool(2, true)
		if err != nil {
			return err
		}
		e.success = val
	}
	{
		val, err := reader.ReadDecodable(3, func() codec.DecodableReader { return new(errObj) }, true)
		if err != nil {
			return err
		}
		e.err = val.(*errObj)
	}
	{
		val, err := reader.ReadBytes(4, true)
		if err != nil {
			return err
		}
		e.result = val
	}
	return nil
}
