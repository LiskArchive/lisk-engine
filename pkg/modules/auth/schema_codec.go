// Code generated by github.com/LiskHQ/lisk-engine/pkg/codec/gen; DO NOT EDIT.

package auth

import (
	"github.com/LiskHQ/lisk-engine/pkg/codec"
)

func (e *UserAccount) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt(1, e.Nonce); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.NumberOfSignatures); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(3, e.MandatoryKeys); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(4, e.OptionalKeys); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *UserAccount) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *UserAccount) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *UserAccount) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *UserAccount) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *UserAccount) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = val
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = val
	}
	return nil
}

func (e *UserAccount) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = val
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = val
	}
	return nil
}

func (e *GetAccountRequest) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Address); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *GetAccountRequest) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *GetAccountRequest) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *GetAccountRequest) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *GetAccountRequest) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *GetAccountRequest) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Address = val
	}
	return nil
}

func (e *GetAccountRequest) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Address = val
	}
	return nil
}

func (e *GetAccountResponse) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt(1, e.Nonce); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.NumberOfSignatures); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(3, codec.HexArrayToBytesArray(e.MandatoryKeys)); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(4, codec.HexArrayToBytesArray(e.OptionalKeys)); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *GetAccountResponse) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *GetAccountResponse) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *GetAccountResponse) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *GetAccountResponse) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *GetAccountResponse) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = codec.BytesArrayToHexArray(val)
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *GetAccountResponse) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = codec.BytesArrayToHexArray(val)
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *RegisterMultisignatureParams) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt32(1, e.NumberOfSignatures); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(2, e.MandatoryKeys); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(3, e.OptionalKeys); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *RegisterMultisignatureParams) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *RegisterMultisignatureParams) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *RegisterMultisignatureParams) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *RegisterMultisignatureParams) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *RegisterMultisignatureParams) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, false)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.MandatoryKeys = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.OptionalKeys = val
	}
	return nil
}

func (e *RegisterMultisignatureParams) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt32(1, true)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(2)
		if err != nil {
			return err
		}
		e.MandatoryKeys = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.OptionalKeys = val
	}
	return nil
}

func (e *GenesisAssetAccount) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteUInt(1, e.Nonce); err != nil {
		return nil, err
	}
	if err := writer.WriteUInt32(2, e.NumberOfSignatures); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(3, codec.HexArrayToBytesArray(e.MandatoryKeys)); err != nil {
		return nil, err
	}
	if err := writer.WriteBytesArray(4, codec.HexArrayToBytesArray(e.OptionalKeys)); err != nil {
		return nil, err
	}
	return writer.Result(), nil
}

func (e *GenesisAssetAccount) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *GenesisAssetAccount) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *GenesisAssetAccount) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *GenesisAssetAccount) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *GenesisAssetAccount) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, false)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, false)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = codec.BytesArrayToHexArray(val)
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *GenesisAssetAccount) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadUInt(1, true)
		if err != nil {
			return err
		}
		e.Nonce = val
	}
	{
		val, err := reader.ReadUInt32(2, true)
		if err != nil {
			return err
		}
		e.NumberOfSignatures = val
	}
	{
		val, err := reader.ReadBytesArray(3)
		if err != nil {
			return err
		}
		e.MandatoryKeys = codec.BytesArrayToHexArray(val)
	}
	{
		val, err := reader.ReadBytesArray(4)
		if err != nil {
			return err
		}
		e.OptionalKeys = codec.BytesArrayToHexArray(val)
	}
	return nil
}

func (e *AuthData) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	if err := writer.WriteBytes(1, e.Address); err != nil {
		return nil, err
	}
	if e.AuthAccount != nil {
		if err := writer.WriteEncodable(2, e.AuthAccount); err != nil {
			return nil, err
		}
	}
	return writer.Result(), nil
}

func (e *AuthData) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *AuthData) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *AuthData) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *AuthData) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *AuthData) DecodeFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, false)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(GenesisAssetAccount) }, false)
		if err != nil {
			return err
		}
		e.AuthAccount = val.(*GenesisAssetAccount)
	}
	return nil
}

func (e *AuthData) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		val, err := reader.ReadBytes(1, true)
		if err != nil {
			return err
		}
		e.Address = val
	}
	{
		val, err := reader.ReadDecodable(2, func() codec.DecodableReader { return new(GenesisAssetAccount) }, true)
		if err != nil {
			return err
		}
		e.AuthAccount = val.(*GenesisAssetAccount)
	}
	return nil
}

func (e *GenesisAsset) Encode() ([]byte, error) {
	writer := codec.NewWriter()
	{
		for _, val := range e.AuthDataSubstore {
			if val != nil {
				if err := writer.WriteEncodable(1, val); err != nil {
					return nil, err
				}
			}
		}
	}
	return writer.Result(), nil
}

func (e *GenesisAsset) MustEncode() []byte {
	encoded, err := e.Encode()
	if err != nil {
		panic(err)
	}
	return encoded
}

func (e *GenesisAsset) Decode(data []byte) error {
	reader := codec.NewReader(data)
	return e.DecodeFromReader(reader)
}

func (e *GenesisAsset) MustDecode(data []byte) {
	if err := e.Decode(data); err != nil {
		panic(err)
	}
}

func (e *GenesisAsset) DecodeStrict(data []byte) error {
	reader := codec.NewReader(data)
	if err := e.DecodeStrictFromReader(reader); err != nil {
		return err
	}
	if reader.HasUnreadBytes() {
		return codec.ErrUnreadBytes
	}
	return nil
}

func (e *GenesisAsset) DecodeFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(AuthData) })
		if err != nil {
			return err
		}
		r := make([]*AuthData, len(vals))
		for i, v := range vals {
			r[i] = v.(*AuthData)
		}
		e.AuthDataSubstore = r
	}
	return nil
}

func (e *GenesisAsset) DecodeStrictFromReader(reader *codec.Reader) error {
	{
		vals, err := reader.ReadDecodables(1, func() codec.DecodableReader { return new(AuthData) })
		if err != nil {
			return err
		}
		r := make([]*AuthData, len(vals))
		for i, v := range vals {
			r[i] = v.(*AuthData)
		}
		e.AuthDataSubstore = r
	}
	return nil
}
